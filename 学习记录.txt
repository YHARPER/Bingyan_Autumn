/*
逆波兰式：
因为计算机普遍采用的内存结构是栈式结构，它执行先进后出的顺序。

将一个普通的中序表达式转换为逆波兰表达式的一般算法是：

分配2个栈，一个作为临时存储运算符的栈S1（含一个结束符号），一个作为输入逆波兰式的栈S2（空栈）
（1）若取出的字符是操作数，则分析出完整的运算数，该操作数直接送入S2栈
（2）若取出的字符是运算符，则将该运算符与S1栈栈顶元素比较，如果该运算符优先级(不包括括号运算符)大于S1栈栈顶运算符优先级，则将该运算符进S1栈，否则，将S1栈的栈顶运算符弹出，送入S2栈中，直至S1栈栈顶运算符低于（不包括等于）该运算符优先级，最后将该运算符送入S1栈。
（3）若取出的字符是“（”，则直接送入S1栈顶。
（4）若取出的字符是“）”，则将距离S1栈栈顶最近的“（”之间的运算符，逐个出栈，依次送入S2栈，此时抛弃“（”。
（5）重复上面的1~4步，直至处理完所有的输入字符
（6）若取出的字符是“#”，则将S1栈内所有运算符（不包括“#”），逐个出栈，依次送入S2栈。
完成以上步骤，S2栈便为逆波兰式输出结果。


*声明并开辟数组：
 数据类型 [] 数组名称 = new 数据类型[长度];
 数组的访问通过索引完成，即：“数组名称[索引]”
 在 Java 中提供有一种动态取得数组长度的方式：数组名称.length；



*java中stack的使用方法

empty():判断栈是否为空，为空返回true,否则返回false
peek():取出栈顶元素，但是不从栈中移除元素
pop():取出栈顶元素，并且将其从栈中移除
push(Eitem):元素入栈
search(Objecto):在栈中查找元素位置，位置从栈顶开始往下算，栈顶为1，
依次往下数到所查找元素位置，如果所查找元素在栈中不存在，则返回-1。
 */